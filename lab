import numpy as np
import math
import pandas as pd
import plotly
import plotly.graph_objs as go

def intError(a,t, refval):
    return refval-sum(a)*3/t

def getIntSums(t):
    #заполнение различных сумм
    x = np.linspace(1,4,t+1)
    y = [f(x) for x in x]

    x_left = x[:-1]
    y_left = y[:-1]

    x_right = x[1:]
    y_right = y[1:]

    x_middle = x[1:]+3/2/t #мне понравилось выполнить это так
    np.insert(x_middle, 0,1)
    x_middle = x_middle[:-1]
    y_middle = [f(x) for x in x_middle]
    # см. комментарий из следующей функции
    return x_left,y_left, x_right, y_right, x_middle, y_middle

def getIntegralsToPlot(t, refval):
    sums = []; sums.append(getIntSums(t))
    bars = []
    # эмпирически проверенное гениальное архитектурное решение
    bars.append(go.Bar(visible = False, x=sums[0][2]-3/2/t,y=sums[0][3], name = 'right_sum = ' + str(sum(sums[0][3])*3/t) + '; error: ' + str(intError(sums[0][3],t,refval)), opacity = 0.6, marker = dict(color = 'red')))
    bars.append(go.Bar(visible = False, x=sums[0][4], y=sums[0][5], name = 'middle_sum = ' + str(sum(sums[0][5])*3/t) + '; error: ' + str(intError(sums[0][5],t,refval)),opacity = 0.6, marker = dict(color = 'blue')))
    bars.append(go.Bar(visible = False,x=sums[0][0]+3/2/t,y=sums[0][1], name = 'left_sum = ' + str(sum(sums[0][1])*3/t) + '; error: ' + str(intError(sums[0][1],t,refval)), opacity = 0.6, marker = dict(color = 'green')))
    return bars
    # иксы двигаются тк по умолчанию основание прямоугольника будет посередине значения, что не подходит для отрисовки
def calculateIntToCompare(t):
    sums = []; sums.append(getIntSums(t))
    left_sum = sum(sums[0][1])*3/t
    right_sum = sum(sums[0][3])*3/t
    middle_sum = sum(sums[0][5])*3/t
    return left_sum, right_sum, middle_sum


#основная функция + задание функции
f = lambda x: math.exp(2*x)
true_x = np.linspace(1,4,500)
true_y = [f(x) for x in true_x]
ref_value = (math.exp(8)-math.exp(2))/2 #референсное значение

frames = []
for t in [10,50,100,1000]:
    ints = getIntegralsToPlot(t, ref_value);
    frames.append(ints[0]), frames.append(ints[1]), frames.append(ints[2])
frames.insert(0,go.Scatter(x=true_x, y=true_y, name = 'func'))
#рисование
fig = go.Figure(data = frames)
steps = []
for i in [1,4,7,10]:
    step = dict (
        method = 'restyle',
        args = ['visible', [False]*len(fig.data)]
    )
    step['args'][1][0] = True
    step['args'][1][i] = True
    step['args'][1][i+1] = True
    step['args'][1][i+2] = True

    steps.append(step)

sliders = [dict (steps = steps)]
fig.layout.sliders = sliders
fig.update_layout(bargap = 0,barmode = 'overlay')
fig.update_layout(legend = dict(y = -0.5, x = 0))

fig.show()
